// // // // // // // // 1.
// // // // // // // // interface A {
// // // // // // // //     a:number,
// // // // // // // //     b:string
// // // // // // // // }
// // // // // // // // const obj:A = {a:1232,b:'adwaf'}

// // // // // // // // 2.
// // // // // // // // // let n:any;
// // // // // // // // let n:number|string;
// // // // // // // // for(let i = 0;i<10;i++){
// // // // // // // //     if(i<=5){
// // // // // // // //         n=10
// // // // // // // //     }
// // // // // // // //     else n="100";
// // // // // // // // }

// // // // // // // // 3.
// // // // // // // let array:object = [12, 321];
// // // // // // // // 字面量
// // // // // // // const n:number = 123;
// // // // // // // const s:string = '456';
// // // // // // // const o:object = {a:1,b:"2"};
// // // // // // // // 非字面量
// // // // // // // const N:Number = new Number(123);
// // // // // // // const S:String = new String('456');
// // // // // // // const O:Object = new Object({a:1,b:'2'});
// // // // // // // // boolean
// // // // // // // const IS_MOBILE:boolean = true;
// // // // // // // const IS_TABLE:boolean = false;
// // // // // // // // number
// // // // // // // let decLiteral:number = 6;
// // // // // // // let hexLiteral:number = 0xf00d;
// // // // // // // let binaryLiteral:number = 0b1010;
// // // // // // // let octalLiteral:number = 0o744;
// // // // // // // // string
// // // // // // // let s1:string = "hello world!";
// // // // // // // let s2:string = `hello ${name}`;
// // // // // // // // Array
// // // // // // // let numbers:number[] = [1,2,3,4,5];
// // // // // // // let numbersAndString:(number|string)[] = [1,2,3,4,'5'];
// // // // // // // let numbersT:Array<number> = [1,2,3,4,5];
// // // // // // // // Tuple
// // // // // // // // let list1:[number, string] = [1, '2', 3];
// // // // // // // // let list2:[number, string] = [1, 2];
// // // // // // // // let list3:[number, string] = ['1', 2];
// // // // // // // let list4:[number, string] = [1, '2'];
// // // // // // // // enum
// // // // // // // enum Color {Red, Green, Blue}
// // // // // // // // 等价
// // // // // // // enum Color2 {Red=0, Green=1, Blue=2}
// // // // // // // Color2[1] === 'Green';
// // // // // // // // any
// // // // // // // let obj:any = {};
// // // // // // // ['a','b'].forEach(letter=>{
// // // // // // //     obj[letter] = letter;
// // // // // // // });
// // // // // // // obj.a = 123;
// // // // // // // // void
// // // // // // // function abc(n:number):void{
// // // // // // //     console.info(n);
// // // // // // // }
// // // // // // // const n1:void = undefined;
// // // // // // // const n2:void = null;

// // // // // // // interface
// // // // // // // interface Article{
// // // // // // //     title: string;
// // // // // // //     count: number;
// // // // // // //     cotent: string;
// // // // // // //     fromSite?: string;
// // // // // // // }

// // // // // // // const article:Article = {
// // // // // // //     title: 'title',
// // // // // // //     count: 123,
// // // // // // //     cotent: 'content',
// // // // // // //     fromSite: 'cawcwa'
// // // // // // // }
// // // // interface Core{
// // // //     (n:number, s:string):[number,string]
// // // // }
// // // // const core:Core = (a,b)=>{
// // // //     return [a,b]
// // // // }
// // // // // // interface Animal {
// // // // // //     head:number;
// // // // // //     body:number;
// // // // // //     foot:number;
// // // // // //     eat(food:string):void;
// // // // // //     say(word:string):string;
// // // // // // }
// // // // // // class Dog implements Animal {
// // // // // //     head = 1;
// // // // // //     body = 2;
// // // // // //     foot = 3;
// // // // // //     eat(food: string) {
// // // // // //         console.info(food);
// // // // // //     };
// // // // // //     say(word: string) {
// // // // // //         console.info(word);
// // // // // //         return word;
// // // // // //     };
// // // // // // }
// // // // // interface A {a:number};
// // // // // interface B {b:string};
// // // // // const a:A = {a:1};
// // // // // const b:B = {b:'1'};
// // // // // const ab:A&B = {...a, ...b};

// // // // // function setWidth(el: HTMLElement, width: string | number) {
// // // // //     el.style.width = 'number' === typeof width ? `${width}px` : width;
// // // // // }

// // // // // function convert<T>(input:T):T{
// // // // //     return input;
// // // // // }

// // // // class Person<U> {
// // // //     who: U;

// // // //     constructor(who:U){
// // // //         this.who = who;
// // // //     }

// // // //     say(code:U):string{
// // // //         return this.who + ':i am' + code;
// // // //     }
// // // // }

// // // // // let a = new Person<string>("hahahah");
// // // // // a.say(007);
// // // // // a.say('007');

// // // // // let a = new Person("hahaha");
// // // // // a.say(007);
// // // // // a.say("007")


// // // // class ABC<T>{
// // // //     getFirst<T>(data:T[]):T{
// // // //         return data[0];
// // // //     }
// // // // }
// // // // let a = new ABC<string[]>();
// // // // a.getFirst(["a","b","b",123]);

// // // // let arr: Array<number>;
// // // // arr = ['123'];
// // // // arr = [123];

// // // // function convert<T>(input:T):T{
// // // //     return input;
// // // // }

// // // // interface Convert {
// // // //     <T>(input:T):T
// // // // }

// // // // let convert2:Convert = convert;

// // // // interface Goods<T>{
// // // //     id:number;
// // // //     title:string;
// // // //     size:T;
// // // // }
// // // // let apple:Goods<string> = {id:1, title:'苹果',size:'large'};
// // // // let shoes:Goods<number> = {id:1, title:'苹果',size:100};

// // // // function echo<T>(input:T):T{
// // // //     console.info(input.name);
// // // //     return input;
// // // // }
// // // // function echoW<T extends {name:string}>(input: T):T{
// // // //     console.info(input.name);
// // // //     return input;
// // // // }

// // // // function create<T,U>(O:{new():T|U;}): T|U{
// // // //     return new O();
// // // // }

// // // function convert<T>(input:T[]):number{
// // //     return input.length;
// // // }

// // // let n = 1;
// // // n += 3;

// // // let arr1 = [];
// // // arr1.push(1,'2',{a:3});

// // // let arr = [1];
// // // arr.push(2);

// // // let n: number|null = 0.5 < Math.random() ? 1 : null;
// // // if(null !== n){
// // //     n += 3;
// // // }

// // // document.ontouchstart = ev => {
// // //     console.info(ev.touches);
// // // }

// // // let n:number|string = 0.5 < Math.random()? 1 : '1';
// // // if('number' === typeof n){
// // //     n *= 2;
// // // } else {
// // //     n = '2';
// // // }

// // // let obj = 0.5 < Math.random() ? new String(1) : new Array(1);
// // // if(obj instanceof String){
// // //     obj += '123';
// // // } else {
// // //     obj.push(123);
// // // }

// // // let obj = 0.5 < Math.random() ? 1 : [1];

// // // (<number[]>obj).push(1);

// // // (obj as number[]).push(1);

// // // type A = 'top'|'right'|'bottom'|'left';
// // // type B = 1|2|3;
// // // type C = "红"|"绿"|"黄";
// // // type D = 150;

// // // let a:A = 'none'

// // // interface A1{
// // //     a:number;
// // // }

// // // type B = A1 | {b:string};
// // // type C = A1 & {b:string};

// // // type D<T> = A1 | T[];

// // // type A = keyof {a:1, b:'123'};
// // // type B = keyof [1, 2];

// // // type A = {a:1, b:'123'};
// // // type C = A['a'];
// // // let c:C = 2;

// // // type A = {a:number,b:string};
// // // type A1 = Readonly<A>; // 只读

// // // type A = {a?:number, b?:string};
// // // type A1 = Required<A> // 可选

// // // type A = Pick<{a: number, b: string, c: boolean}, 'a' | 'b'>
// // // type A1 = Pick<A, 'a' | 'b'> //  {a:number,b:string}
// // // Pick<T,K>, 只保留自己选择的属性, K代表要保留的属性键值

// // // type A = {a:number, b:string};
// // // type A1 = Omit<A, 'a'>; // Omit<T,K> 实现排除已选的属性

// // // type A1 = Record<string, string>; // 等价{[k:string]:string}
// // // let a2:A1 = {'1':'1'};

// // // type A = {a:number, b:string};
// // // type A1 = Exclude<number|string, string|number[]>; // number
// // // type A2 = Exclude<number|string, any|number[]>; //Exclude<T,U>, 过滤T中和U相同(或兼容)的类型

// // // type A = {a:number, b:string};
// // // type A1 = Extract<number|string, string|number[]> // string
// // // // Extract<T,U>, 提取T中和U相同(或兼容)的类型

// // // NonNullable, 剔除T中的undefined和null
// // // type A1 = NonNullable<number|string|null|undefined> // number | string

// // // ReturnType, 获取T的返回值的类型
// // // type A1 = ReturnType<()=>number>; // number

// // // interface A{
// // //     a: HTMLElement;
// // // }

// // // interface AConstructor{
// // //     new():A;
// // // }

// // // function create(AClass:AConstructor):InstanceType<AConstructor>{
// // //     return new AClass();
// // // }

// // // Parameters 获取函数参数类型
// // // 返回类型为元祖, 元素顺序同参数顺序.
// // // interface A {
// // //     (a:number, b:string):string[];
// // // }
// // // type A1 = Parameters<A> // [number, string]

// // // 和Parameters类似, 只是T这里是构造函数类型.
// // // interface AConstructor{
// // //     new(a:number):string[];
// // // }
// // // type A1 = ConstructorParameters<AConstructor>; // [number]

// // // T extends U ? X : Y 
// // // 用来表示类型是不确定的, 如果U的类型可以表示T, 那么返回X, 否则Y.
// // // type A = string extends '123' ? string: '123' // '123'
// // // type B = '123' extends string ? string: 123   // string

// // // infer(类型推断) 不懂
// // // 单词本身的意思是"推断", 实际表示在extends条件语句中声明待推断的类型变量. 我们上面介绍的映射类型中就有很多都是ts在lib.d.ts中实现的, 比如Parameters:
// // // export type Tail<Tuple extends any[]> = ((...args: Tuple) => void) extends ((a: any, ...args: infer T) => void) ? T : never;

// // namespace Tools{
// //     const TIMEOUT = 100;

// //     export class Ftp {
// //         constructor(){
// //             setTimeout(() => {
// //                 console.info('Ftp');
// //             }, TIMEOUT)
// //         }
// //     }

// //     export class Http {
// //         constructor() {
// //             console.info('Http');
// //         }
// //     }

// //     export function parseURL(){
// //         console.info('parseURL');
// //     }
// // }

// // Tools.TIMEOUT // Tools上没有属性
// // Tools.parseURL()

// // 命名空间不仅可以用在逻辑代码中, 也可以用在类型
// namespace Food {
//     export type A = Window;
//     export interface Fruits{
//         taste: string;
//         hardness: number;
//     }
//     export interface Meat{
//         taste: string;
//         heat: number;
//     }
// }

// let meat: Food.Meat;
// let fruits: Food.Fruits;


declare var _DEVA_ : boolean;
declare var _DEVB_ : number;
declare var _DEVC_ : string;

